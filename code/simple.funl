# 
	Example file of FUN-L code 	
#




#
		SIMPLE DEFINITIONS
#

# Defines a new global variable #
let identity
	fun (x) x;
	

let execute-on
	fun (x)
		fun (f)
			(f x); # (f x) is applying function f on x in call by value (x is evaluated) #

let execute-on-equivalent
	fun (x f) # exactly the same function as execute-on, but written with a simpler syntax #
		(f x);



let quote 
	# 
		Uses call by name to avoid expression evaluation 
		Ex : [quote ((fun (x) (x x)) (fun (x) (x x)))]
	#
	fun (x) 
		fun (f) 
			[f x]; # [f x] is applying function f on x in a call by name (x is NOT evaluated) #
	
	
let unquote
	# Evaluates a quoted expression #
	fun (q)
		(q identity);



#
		BOOLEANS
#
	
let false
	fun (x y) y;
	
let true
	fun (x y) x;
		

let if
	#
		Takes a boolean and two statements as input, returns the first if the boolean is true
		and the second if it's false. If called in call by name (squared brackets), a lazy evaluation
		is done, so only the returned statement is evaluated.
	#
	fun (boolean then else)
		[boolean then else]; # equivalent to [[boolean then] else] #
		
		
		
let and
	fun (b1 b2)
		[if b1 b2 false];
	
let or
	fun (b1 b2)
		[if b1 true b2];
		
let not
	fun (b)
		[if b false true];
	

#
		COUPLES
#


let cons
	fun (x y f)
		(f x y);
		
let fst
	fun (c)
		(c true);
		
let snd
	fun (c)
		(c false);
		
	
#
		LISTS
#
		
		
let </>
	#
		Empty list
	#
	fun (x) true;
	
	
let isempty?
	fun (l)
		(l (fun (x y) false));
	


let head fst;


let tail
	fun (l)
		[if (isempty? l)
			</>
			(snd l)
		];
		
		
let rec foldl
	fun (f l b)
		[if (isempty? l)
			b
			(f (head l) (foldl f (tail l) b))
		];
		
		

let rec foldr
	fun (f l b)
		[if (isempty? l)
			b
			(foldr f (tail l) (f (head l) b))
		];
		
			
let rec map
	fun (f l)
		[if (isempty? l)
			</>
			(cons (f (head l)) 
				  (map f (tail l))
			)
		];
			
			
let rec apply
	fun (f l)
		[if (isempty? l)
			(apply (f (head l)) 
				   (tail l)
			)
		];
			
			
let concat
	fun (l1 l2)
		(foldl cons l1 l2);

		
let reverse
	fun (l)
		(foldr cons l </>);
		
		
let rec append
	fun (x l)
		[if (isempty? l)
			(cons x </>)
			(cons (head l) (append x (tail l)))
		];


		
	
let rec insert
	fun (less-or-equal? x l)
		[if (isempty? l)
			(cons x </>)
			let y 
				(head l)
			in
			[if (less-or-equal? x y)
				(cons x l)
				(cons y (insert less-or-equal? x (tail l)))
			]
		];	
	
	
let rec sort
	fun (less-or-equal? l)
		[if (isempty? l)
			</>
			(insert less-or-equal? (head l) (sort less-or-equal? (tail l)))
		];
			
			
			
					
#
		INTEGER DEFINITION
#

let succ 
	fun (n)
		(cons identity n);

let pred tail;

let iszero? isempty?;


let 0 </>; let 1 (succ 0); let 2 (succ 1); let 3 (succ 2); let 4 (succ 3);
let 5 (succ 4); let 6 (succ 5); let 7 (succ 6); let 8 (succ 7); let 9 (succ 8);
let 10 (succ 9); let 11 (succ 10); let 12 (succ 11); let 13 (succ 12); let 14 (succ 13);
let 15 (succ 14); let 16 (succ 15); let 17 (succ 16); let 18 (succ 17); let 19 (succ 18);
let 20 (succ 19); let 21 (succ 20); let 22 (succ 21); let 23 (succ 22); let 24 (succ 23);
let 25 (succ 24); let 26 (succ 25); let 27 (succ 26); let 28 (succ 27); let 29 (succ 28);
let 30 (succ 29); let 31 (succ 30); let 32 (succ 31); let 33 (succ 32); let 34 (succ 33);
let 35 (succ 34); let 36 (succ 35); let 37 (succ 36); let 38 (succ 37); let 39 (succ 38);
let 40 (succ 39); let 41 (succ 40); let 42 (succ 41); let 43 (succ 42); let 44 (succ 43);
let 45 (succ 44); let 46 (succ 45); let 47 (succ 46); let 48 (succ 47); let 49 (succ 48);
let 50 (succ 49); let 51 (succ 50); let 52 (succ 51); let 53 (succ 52); let 54 (succ 53);
let 55 (succ 54); let 56 (succ 55); let 57 (succ 56); let 58 (succ 57); let 59 (succ 58);
let 60 (succ 59); let 61 (succ 60); let 62 (succ 61); let 63 (succ 62); let 64 (succ 63);




#
		INTEGER OPERATORS
#


let rec iterate
	fun (nb-times f x)
		[if (iszero? nb-times)
			x
			(f (iterate (pred nb-times) f x))
		];
		
	
	
let +
	fun (a b)
		[iterate b succ a];

let -
	fun (a b)
		[iterate b pred a];

let *
	fun (a b)
		[iterate a (+ b) 0];
	
let ^
	fun (a b)
		[iterate b (* a) 1];




let =
	fun (a b)
		[and (iszero? (- b a))
			 (iszero? (- a b))
		];
		
let >
	fun (a b)
		(not (iszero? (- a b)));
		
		
let <
	fun (a b)
		(> b a);
		
let >=
	fun (a b)
		[or (> a b)
			(= a b)
		];
		
let <=
	fun (a b)
		(>= b a);
		
	
let rec /
	fun (a b)
		[if (< a b)
			0
			(succ (/ (- a b) b))
		];
		
		
let %
	fun (a b)
		(- a 
		   (* b 
		   	  (/ a b)
		   )
		);

		
# 
	INTERGER FUNCTION EXAMPLES
#

		
let rec pgcd
	fun (a b)
		[if (iszero? b)
			a
			(pgcd b (% a b))
		];	


let rec factorial
	fun (n)
		[if (iszero? n)
			1
			(* n (factorial (pred n)))
		];
	
	
	
#
		INTEGER FUNCTION OPERATORS
#
	
let op-to-opf
	fun (op f g x)
		(op (f x) (g x));

let +f (op-to-opf +);
let -f (op-to-opf -);
let *f (op-to-opf *);
let /f (op-to-opf /);
let ^f (op-to-opf ^);
let %f (op-to-opf %);


let succf
	fun (f x)
		(succ (f x));

let 0f (fun (x) 0);

let 1f (succf 0f); let 2f (succf 1f); let 3f (succf 2f); let 4f (succf 3f); let 5f (succf 4f);
let 6f (succf 5f); let 7f (succf 6f); let 8f (succf 7f); let 9f (succf 8f); let 10f (succf 9f);



#
	TESTS
#



		
(<= 3 2)
(<= 2 3)
(= (+ 1 1) 2)
(= (+ 1 1) 0)		
(= (+ 1 1) 3)
(= (* 2 2) (+ 3 1))
(* 2 2)
(+ 3 1)


(pgcd 8 12)

(sort <= (cons 4 (cons 2 (cons 3 </>))))		


[quote (pgcd 46 12)]

(% 4 3)



let rec inf-list
	let inf-cons
		fun (x y f) [f x y]
	in
	fun (f)
		[(inf-cons (f 0)) (inf-list [fun (n) (f (succ n))])];


let rec firsts
	fun (l n)
		[if (iszero? n)
			</>
			(cons (head l) 
				  (firsts (tail l) (- n 1))
			)
		];


let N
	(inf-list identity);





let rec Pl
	fun (l x)
		[if (isempty? l)
			0
			(+ (head l) 
			   (* x (Pl (tail l) x))
			)
		];
			
let Pan
	fun (a n x)
		(* a (^ x n));
		
		
let poly (Pl (cons 1 (cons 1 (cons 1 </>))));

(poly 0)
(poly 1)
(poly 2)



(head N)
(head (tail N))
(firsts N 3)


	
	

	
let rec inf-rec-list
	let inf-cons
		fun (x y f) [f x y]
	in
	fun (f u n)
		[inf-cons u (inf-rec-list f (f u n) (succ n))];
		
		

let powers-of-two
	(inf-rec-list (fun (u n) (* 2 u)) 1 0);
	
	
(firsts powers-of-two 3)



let Y
	fun (f)
		let g 
			fun (x) [f (x x)]
		in 
		[g g];
		
		
let facto-no-rec
	let facto-aux
		fun (f n)
			[if (iszero? n)
				1
				(* n (f (pred n)))
			]
	in
	[Y facto-aux];


(facto-no-rec 0)
(facto-no-rec 1)
(facto-no-rec 2)
(facto-no-rec 3)









	
	
	